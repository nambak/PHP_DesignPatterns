# PHP Design Patterns


모든 소스 파일은 [DesignPatternsPHP](https://designpatternsphp.readthedocs.io/) 사이트에 있는 것을 가져왔습니다.

* ## Creational
  소프트웨어 엔지니어링에서 Creational 디자인 패턴은 상황에 맞는 방식으로 객체를 생성하려고 시도하면서 객체 생성 메커니즘을 다루는 디자인 패턴입니다. 
  객체 생성의 기본 형태는 디자인 문제를 야기하거나 디자인에 복잡성을 추가 할 수 있습니다. 
  Creational 디자인 패턴은 이 객체 생성을 어떻게 든 제어함으로써이 문제를 해결합니다.
  * ### Abstract Factory:
    구체적인 클래스를 지정하지 않고 일련의 관련 또는 종속 객체를 생성합니다.
    일반적으로 생성 된 클래스는 모두 동일한 인터페이스를 구현합니다.
    Abstract Factory의 클라이언트는 이러한 객체가 어떻게 만들어 지는지 신경 쓰지 않고 어떻게 함께 이동하는지 알고 있습니다.
  * ### Builder: 
    Builder는 복잡한 개체의 일부를 빌드하는 인터페이스입니다.
    때로는 Builder가 빌드하는 것에 대해 더 잘 알고있는 경우이 인터페이스는 기본 메소드 (일명 어댑터)가있는 추상 클래스가 될 수 있습니다.
    객체에 대한 복잡한 상속 트리가있는 경우 빌더에 대한 복잡한 상속 트리도 갖는 것이 논리적입니다.
    참고 : Builder는 종종 유창한 인터페이스를 가지고 있습니다. 예를 들어 PHPUnit의 mock builder를 참조하십시오.
  * ### Factory Method: 
    SimpleFactory에 대한 좋은 점은 객체를 생성하는 다양한 방법을 구현하기 위해 하위 클래스를 만들 수 있다는 것입니다.
    간단한 경우에 이 추상 클래스는 인터페이스 일 수 있습니다.
    이 패턴은 SOLID 원칙에서 "D"라고하는 종속성 반전 원칙을 달성하기 때문에 "실제"디자인 패턴입니다.
    이는 Factory Method 클래스가 구체적인 클래스가 아니라 추상화에 의존한다는 것을 의미합니다. 
    이것은 SimpleFactory 또는 StaticFactory에 비해 실제 트릭입니다.
  * ### Pool: 
    개체 Pool 패턴은 필요에 따라 할당 및 삭제하는 대신 사용할 준비가 된 초기화 된 개체 세트("Pool")를 사용하는 소프트웨어 생성 디자인 패턴입니다. 
    Pool의 클라이언트는 Pool에서 개체를 요청하고 반환 된 개체에 대해 작업을 수행합니다. 
    클라이언트가 완료되면 특정 유형의 팩토리 개체인 개체를 삭제하지 않고 Pool에 반환합니다.
    객체 풀링은 클래스 인스턴스 초기화 비용이 높고 클래스 인스턴스화 속도가 높으며 한 번에 사용중인 인스턴스 수가 적은 상황에서 상당한 성능 향상을 제공 할 수 있습니다. 
    풀링 된 객체는 새 객체 생성 (특히 네트워크를 통해)에 가변 시간이 걸릴 수있는 예측 가능한 시간에 획득됩니다.
    그러나 이러한 이점은 데이터베이스 연결, 소켓 연결, 스레드 및 글꼴 또는 비트 맵과 같은 대형 그래픽 개체와 같이 시간과 관련하여 비용이 많이 드는 개체의 경우 대부분 사실입니다. 
    특정 상황에서는 단순 개체 풀링 (외부 리소스는 포함하지 않고 메모리 만 차지함)이 효율적이지 않을 수 있으며 성능이 저하 될 수 있습니다.
  * ### Prototype: 
    표준 방식 (new Foo ())으로 객체를 생성하는 비용을 피하고 대신 Prototype을 생성하고 복제합니다.
  * ### Simple Factory: 
    Simple Factory는 간단한 팩토리 패턴입니다.
    정적이 아니기 때문에 정적 팩토리와 다릅니다. 
    따라서 매개 변수가 다른 여러 팩토리를 가질 수 있으며 하위 클래스를 만들 수 있으며 모의 작업을 수행 할 수 있습니다. 
    항상 정적 팩토리보다 선호되어야합니다!
  * ### Singleton:
    **이것은 안티 패턴으로 간주됩니다! 더 나은 테스트 및 유지 관리를 위해 의존성 주입을 사용하십시오!**
    모든 호출을 처리 할 응용 프로그램에이 개체의 인스턴스가 하나만 있어야합니다.
  * ### Static Factory:
    Abstract Factory와 유사하게이 패턴은 일련의 관련 또는 종속 객체를 생성하는 데 사용됩니다.
    이 패턴과 추상 팩토리 패턴의 차이점은 정적 팩토리 패턴이 생성 할 수있는 모든 유형의 객체를 생성하기 위해 단 하나의 정적 메서드를 사용한다는 것입니다.
    일반적으로 factory 또는 build라고합니다.

* ## Structural
  소프트웨어 엔지니어링에서 Structural 디자인 패턴은 엔티티 간의 관계를 실현하는 간단한 방법을 식별하여 설계를 용이하게하는 디자인 패턴입니다.
  * ### Adapter / Wrapper:
    클래스에 대한 하나의 인터페이스를 호환 가능한 인터페이스로 변환합니다. 
    어댑터를 사용하면 원래 인터페이스를 사용하는 동안 클라이언트에 인터페이스를 제공하여 호환되지 않는 인터페이스로 인해 일반적으로 할 수 없었던 클래스가 함께 작동 할 수 있습니다.
    * Examples
      * DB Client libraries adapter
      * using multiple different webservices and adapters normalize data so that the outcome is the same for all
  * ### Bridge
    구현에서 추상화를 분리하여 둘이 독립적으로 변할 수 있도록합니다.

